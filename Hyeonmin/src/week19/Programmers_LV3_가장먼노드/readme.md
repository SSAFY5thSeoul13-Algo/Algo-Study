## Programmers Lv3 κ°€μ¥ λ¨Ό λ…Έλ“

- κ·Έλν”„
- level3

<br>


### π” λ¬Έμ  μ„¤λ…
https://programmers.co.kr/learn/courses/30/lessons/49189

nκ°μ λ…Έλ“κ°€ μμ„ λ• 1λ¶€ν„° nλ² κΉμ§€μ λ…Έλ“μ— λ€ν• μ–‘λ°©ν–¥ κ°„μ„ μ μ •λ³΄λ¥Ό 2μ°¨μ› λ°°μ—΄ edgeκ°€ μ£Όμ–΄μ§„λ‹¤. 

1λ² λ…Έλ“λ΅λ¶€ν„° κ°€μ¥ λ©€λ¦¬ λ–¨μ–΄μ§„ λ…Έλ“κ°€ λ‡ κ°μΈμ§€λ¥Ό return ν•λ„λ΅ solution ν•¨μλ¥Ό μ‘μ„±ν•΄μ£Όμ„Έμ”.


#### μ ν•μ‚¬ν•­
λ…Έλ“μ κ°μ nμ€ 2 μ΄μƒ 20,000 μ΄ν•μ…λ‹λ‹¤.
κ°„μ„ μ€ μ–‘λ°©ν–¥μ΄λ©° μ΄ 1κ° μ΄μƒ 50,000κ° μ΄ν•μ κ°„μ„ μ΄ μμµλ‹λ‹¤.
edge λ°°μ—΄ κ° ν–‰ [a, b]λ” aλ² λ…Έλ“μ™€ bλ² λ…Έλ“ μ‚¬μ΄μ— κ°„μ„ μ΄ μλ‹¤λ” μλ―Έμ…λ‹λ‹¤.
<br><br>

###  π’΅ ν’€μ΄


μ „μ—­ λ³€μ
`boolean[][] map` : λ‘ λ…Έλ“μ μ—°κ²° μ—¬λ¶€λ¥Ό μ €μ¥ν•λ” 2μ°¨μ› boolean λ°°μ—΄
`boolean[] visited` : bfs μ‹¤ν–‰ μ‹ λ°©λ¬Έ μ—¬λ¶€λ¥Ό μ €μ¥ν•λ” boolean λ°°μ—΄ 

<br>

BFSλ΅ ν’€μ—μµλ‹λ‹¤. 

μ°μ„  edge λ°°μ—΄μ— λ‹΄κΈ΄ λ°μ΄ν„°λ¥Ό ν†µν•΄μ„ map λ°°μ—΄μ— κ° λ…Έλ“κ°„μ μ—°κ²° μƒνƒλ¥Ό μ €μ¥ν•©λ‹λ‹¤. edgeλ” μ–‘λ°©ν–¥ κ°„μ„ μ΄κΈ° λ•λ¬Έμ— mapμ— μ €μ¥ν•  λ•λ„ μ–‘λ°©ν–¥μΌλ΅ μ²΄ν¬λ¥Ό ν•΄μ¤λ‹λ‹¤.

```
		//edgeμ— μ €μ¥λ κ°„μ„  μ •λ³΄λ΅ mapλ°°μ—΄μ— λ…Έλ“κ°„μ μ—°κ²° ν‘μ‹
		for (int i = 0; i < edge.length; i++) {
			int from = edge[i][0];
			int to = edge[i][1];
			
			map[from][to] = true;
			map[to][from] = true;
		}
```

1λ² λ…Έλ“λ¥Ό μ‹μ‘μΌλ΅ 1λ²μ μ—°κ²°λ΅ κ° μ μλ” λ…Έλ“λ“¤μ„ `queue`μ— μ €μ¥ν•©λ‹λ‹¤. κ·Έ λ‹¤μ λλ‹¤μ‹ `queue`μ— λ“¤μ–΄μλ” λ…Έλ“λ“¤μ—μ„ 1λ²μ μ—°κ²°λ΅ κ° μ μλ” λ…Έλ“λ“¤μ„ μ¶”κ°€ν•©λ‹λ‹¤. `queue`μ— λ…Έλ“λ¥Ό μ¶”κ°€ ν•  λ•λ” μμ‹ κ³Ό κ°™μ€ λ²νΈμ λ…Έλ“λ” μ¶”κ°€ν•μ§€ μ•κ³  `map`κ³Ό `visited`λ¥Ό ν™•μΈν•μ—¬ μ—°κ²°λ λ…Έλ“μ¤‘μ— μ•„μ§ λ°©λ¬Έν•μ§€ μ•μ€ κ²½μ°μ—λ§ μ¶”κ°€ν•©λ‹λ‹¤.

```
				for (int j = 1; j < map.length; j++) {
					//μκΈ° μμ‹ μ΄κ±°λ‚ μ—°κ²°μ΄ μ•λ λ…Έλ“μΈ κ²½μ°λ” μ¤ν‚µ
					if(nodeNum == j || !map[nodeNum][j])	continue;
					//μ΄λ―Έ λ°©λ¬Έν• λ…Έλ“μΈ κ²½μ°λ” μ¤ν‚µ
					if(visited[j]) continue; 
					
					//λ°©λ¬Έ μ²΄ν¬
					visited[j] = true;
					
					//νμ— μ €μ¥
					queue.offer(j);
				}
```

μ΄ λ• `count`λ³€μλ¥Ό λ‘μ–΄μ„ νμ— λ“¤μ–΄μλ” λ°μ΄ν„°μ μλ§νΌμ”©λ§ λ°λ³µν•μ€λ”λ°, μ΄λ” bfsλ¥Ό μ‹¤ν–‰ν•  λ• 1λ…Έλ“λ΅ λ¶€ν„° κ±°λ¦¬κ°€ κ°™μ€ λ…Έλ“λ“¤μ— λ€ν•΄μ„ bfsλ¥Ό μΌκ΄„ μν–‰μ„ ν•κ³  κ·Έ ν›„μ— κ±°λ¦¬κ°€ 1 λ” λ¨Ό λ…Έλ“λ“¤μ— λ€ν•΄μ„ μ°¨λ΅€λ΅ μν–‰ν•κΈ° μ„ν•΄μ„μ…λ‹λ‹¤.

```
		while(!queue.isEmpty()) {
			//ν„μ¬ νμ— λ“¤μ–΄μλ” λ…Έλ“λ“¤μ€ 1λ¶€ν„°μ κ±°λ¦¬κ°€ κ°™μ€ λ…Έλ“λ“¤ μ΄λ―€λ΅ μ΄λ–„μ ν μ‚¬μ΄μ¦κ°€ 1λ¶€ν„° κ°€μ¥ λ©€λ¦¬μλ” λ…Έλ“λ“¤μ μμ΄λ‹¤
			count = queue.size();
			
			for (int i = 0; i < count; i++) {
				//νμ— μλ” λ…Έλ“ λ²νΈ
				int nodeNum = queue.poll();
				
				for (int j = 1; j < map.length; j++) {
					//μκΈ° μμ‹ μ΄κ±°λ‚ μ—°κ²°μ΄ μ•λ λ…Έλ“μΈ κ²½μ°λ” μ¤ν‚µ
					if(nodeNum == j || !map[nodeNum][j])	continue;
					//μ΄λ―Έ λ°©λ¬Έν• λ…Έλ“μΈ κ²½μ°λ” μ¤ν‚µ
					if(visited[j]) continue; 
					
					//λ°©λ¬Έ μ²΄ν¬
					visited[j] = true;
					
					//νμ— μ €μ¥
					queue.offer(j);
				}
			}
		}
```


νμ— λ”μ΄μƒ λ°μ΄ν„°κ°€ μ΅΄μ¬ν•μ§€ μ•κ² λμ—μ„ λ• λ§μ§€λ§‰μΌλ΅ μ €μ¥λ `count`κ°’μ΄ κ°€μ¥ λ¨Ό κ±°λ¦¬μ— μλ” λ…Έλ“λ“¤μ μκ°€ λ©λ‹λ‹¤.


<br><br>

###  π’΅ μ†μ¤μ½”λ“
```
import java.util.LinkedList;
import java.util.Queue;

public class Programmers_LV3_κ°€μ¥λ¨Όλ…Έλ“ {
	static boolean[][] map;
	static boolean[] visited;
	
	public static void main(String[] args) {
		int n = 6;
		int[][] edge = {
				{3,6},
				{4,3},
				{3,2},
				{1,3},
				{1,2},
				{2,4},
				{5,2}
		};
		
		int result = solution(n, edge);
		
		System.out.println(result);
	}
	
	static int solution(int n, int[][] edge) {
		//κ° λ…Έλ“μ μ—°κ²° μ—¬λ¶€λ¥Ό μ €μ¥ν•  2μ°¨μ› λ°°μ—΄
		map = new boolean[n+1][n+1];
		//bfsμ—μ„ λ°©λ¬Έ μ—¬λ¶€λ¥Ό μ €μ¥ν•  2μ°¨μ› λ°°μ—΄
		visited = new boolean[n+1];
		
		//edgeμ— μ €μ¥λ κ°„μ„  μ •λ³΄λ΅ mapλ°°μ—΄μ— λ…Έλ“κ°„μ μ—°κ²° ν‘μ‹
		for (int i = 0; i < edge.length; i++) {
			int from = edge[i][0];
			int to = edge[i][1];
			
			map[from][to] = true;
			map[to][from] = true;
		}
		
		return bfs();
	}
	
	//1λ² λ…Έλ“μ—μ„ κ°€μ¥ λ©€λ¦¬ λ–¨μ–΄μ§„ λ…Έλ“μ μλ¥Ό λ¦¬ν„΄ν•λ” λ©”μ†λ“
	static int bfs() {
		//bfsμ‹¤ν–‰μ„ μ„ν•΄ λ…Έλ“μ λ²νΈλ¥Ό μ €μ¥ν•  ν
		Queue<Integer> queue = new LinkedList<Integer>();
		
		//1λ² λ…Έλ“λ¥Ό νμ— μ €μ¥
		queue.offer(1);
		//1λ² λ…Έλ“ λ°©λ¬Έ μ²΄ν¬
		visited[1] = true;
		
		//ν„μ¬ 1λ² λ…Έλ“μ—μ„ κ°€μ¥ λ©€λ¦¬ λ–¨μ–΄μ Έ μλ” λ…Έλ“μ μ
		int count = 0;
		
		while(!queue.isEmpty()) {
			//ν„μ¬ νμ— λ“¤μ–΄μλ” λ…Έλ“λ“¤μ€ 1λ¶€ν„°μ κ±°λ¦¬κ°€ κ°™μ€ λ…Έλ“λ“¤ μ΄λ―€λ΅ μ΄λ–„μ ν μ‚¬μ΄μ¦κ°€ 1λ¶€ν„° κ°€μ¥ λ©€λ¦¬μλ” λ…Έλ“λ“¤μ μμ΄λ‹¤
			count = queue.size();
			
			for (int i = 0; i < count; i++) {
				//νμ— μλ” λ…Έλ“ λ²νΈ
				int nodeNum = queue.poll();
				
				for (int j = 1; j < map.length; j++) {
					//μκΈ° μμ‹ μ΄κ±°λ‚ μ—°κ²°μ΄ μ•λ λ…Έλ“μΈ κ²½μ°λ” μ¤ν‚µ
					if(nodeNum == j || !map[nodeNum][j])	continue;
					//μ΄λ―Έ λ°©λ¬Έν• λ…Έλ“μΈ κ²½μ°λ” μ¤ν‚µ
					if(visited[j]) continue; 
					
					//λ°©λ¬Έ μ²΄ν¬
					visited[j] = true;
					
					//νμ— μ €μ¥
					queue.offer(j);
				}
			}
		}
		
		return count;
	}
}

```


<br>